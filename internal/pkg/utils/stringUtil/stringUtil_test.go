package stringUtil

import (
	"log"
	"testing"
)

func TestRunServer(t *testing.T) {
	//a := PinyinConvert("【译】Oracle调优技巧22：Hash Outer Join")
	a := PinyinConvert("Kava")
	log.Println("结果：", a)
}

func TestRemoveHtmlAndSubstring(t *testing.T) {
	data := "<p store-v-md-line=\"1\">在上一篇<a href=\"https://windcoder.com/chongxinjava-jincheng-xianchengchanshengbeijing\" target=\"_blank\">《重新Java-进程/线程产生背景》<svg xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" focusable=\"false\" x=\"0px\" y=\"0px\" viewbox=\"0 0 100 100\" width=\"15\" height=\"15\" class=\"v-md-svg-outbound\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"></path> <polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"></polygon></svg></a>中我们简述了下面思维导图中程序中的进程发展史，本篇我们将介绍剩余的程序部分以及进程的数据结构等基础知识。程序的生命周期将留到下篇介绍。<br>\n<img src=\"https://assets.windcoder.com/java_process_mindmaster01.png\" alt=\"进程思维导图目前进度\"></p>\n<h2 store-v-md-heading=\"_1-程序\" store-v-md-line=\"3\">1. 程序</h2>\n<h3 store-v-md-heading=\"_1-1-顺序执行的特征\" store-v-md-line=\"4\">1.1 顺序执行的特征</h3>\n<p store-v-md-line=\"5\">通过上节介绍，我们知道了早期计算机（如单道批处理系统和早期未配置OS的的计算机系统）一次只能执行一个程序，由它独占系统的所有资源，只有执行完后才会执行下一个程序，这即是<strong>顺序执行</strong>。程序顺序执行时的具有如下3个特征：</p>\n<ol store-v-md-line=\"6\">\n<li><strong>顺序性</strong> ：CPU等处理机会严格按照程序所规定的顺序执行语句，每个资源必须在下一条语句执行完成之前完成。</li>\n<li><strong>封闭性</strong> ：程序在封闭的环境下执行，运行时独占全机资源，一旦开始执行，其计算结果取决于程序本身，不再受外界因素干扰。</li>\n<li><strong>可再现性</strong> ：只要程序执行的环境和初始条件相同，无论执行多少次，都可以获得相同的结果。</li>\n</ol>\n<p store-v-md-line=\"10\">顺序执行虽然为开发者带来了便利，但系统资源利用率极其低下。</p>\n<h3 store-v-md-heading=\"_1-2-并发执行的特征\" store-v-md-line=\"12\">1.2 并发执行的特征</h3>\n<p store-v-md-line=\"13\">随着技术发展，现代计算机系统允许加载多个程序到内存中，以便<strong>并发执行</strong>。程序在并发执行时也存在3个特征：</p>\n<ol store-v-md-line=\"14\">\n<li><strong>间断性</strong> ：同时执行多个程序，但一个CPU同一时间只能执行一个，于是有了每个很短的时间段执行一个进程，通过不断切换执行，达到最终全部执行完成的效果。从而使并发有了“执行-暂停-执行”这种间断性的活动规律。来自《计算机操作系统》中的说明对这个的介绍比较官方一些,大致如下：\n<ul store-v-md-line=\"15\">\n<li>程序在并发执行时，由于共享系统资源，以及为了完成同一项任务而相互合作，这些并发执行的程序之间形成了相互制约的关系。</li>\n<li>相互制约的关系将导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。</li>\n</ul>\n</li>\n<li><strong>失去封闭性</strong> ：多个程序的切换执行，共享系统中的所有资源，一个程序服务的执行导致资源变化从而会影响到其它进程，进而失去封闭性。</li>\n<li><strong>不可再现性</strong> ：多个程序并发执行时，失去封闭性会导致其失去可再现性。比如多次执行多个程序时，执行顺序不同，可能会导致最终结果不同。</li>\n</ol>\n<p store-v-md-line=\"20\">由于这三个特征，程序直接参与并发执行肯定就不合适了。为了使程序可以并发执行，并且可以对并发执行的程序加以描述和限制，于是在OS中（从多道批处理程序开始）引入了进程(process)这一概念。</p>\n<h3 store-v-md-heading=\"_1-3-并发与并行\" store-v-md-line=\"22\">1.3 并发与并行</h3>\n<p store-v-md-line=\"23\">在如今多处理器时代，除了并发还有并行：</p>\n<ul store-v-md-line=\"24\">\n<li><strong>并发(concurrency)</strong> ：两个或多个事件在同一时间间隔发生(交替执行)</li>\n<li><strong>并行(parallellism)</strong> ：两个或多个事件在同一时刻发生(同时执行)</li>\n</ul>\n<p store-v-md-line=\"27\"><img src=\"https://assets.windcoder.com/java_process_concurrency01.png\" alt=\"顺序执行、并发与并行\"></p>\n<h3 store-v-md-heading=\"_1-4-程序与进程\" store-v-md-line=\"29\">1.4 程序与进程</h3>\n<p store-v-md-line=\"30\">程序本身不是进程，<strong>程序是被动(passive)实体，进程是活动(active)实体</strong>，当程序被执行时，程序就成了进程。如：</p>\n<ul store-v-md-line=\"31\">\n<li>程序是存储在磁盘上的包含一系列指令的文件，常称为可执行文件(executable file)。</li>\n<li>当一个可执行文件被加载到内存时（如我们打开一个web浏览器等时），这个程序便成了进程。</li>\n</ul>\n<h2 store-v-md-heading=\"_2-进程\" store-v-md-line=\"34\">2. 进程</h2>\n<p store-v-md-line=\"36\">可以把传统OS中的进程定义为：<strong>进程是程序执行过程，是系统进行资源分配和调度的一个独立单位</strong>。在之后引入线程的OS中，线程则成了调度的基本单位。</p>\n<h3 store-v-md-heading=\"_2-1-进程的特征\" store-v-md-line=\"38\">2.1 进程的特征</h3>\n<p store-v-md-line=\"39\">进程除了有程序没有的 PCB 之外，还具有如下几个特性：</p>\n<ol store-v-md-line=\"40\">\n<li><strong>动态性</strong> ：进程的本质是程序的执行过程，因此动态性是其最基本的特征。进程有一定的生命期，由创建而产生，由调度而执行，由撤销而消亡。</li>\n<li><strong>并发性</strong> ：引入进程就是为了并发，所以这是另一个重要特性。多个进程共存在内存中，且能在一段时间内同时执行。</li>\n<li><strong>独立性</strong> ：在传统OS中，独立性是指进程是一个能够独立运行、独立获得资源、独立接受调度的单位。未建立PCB的程序都不能作为一个独立的单位参与并发执行。</li>\n<li><strong>异步性</strong> ：进程是按异步方式运行的，且按各自独立的、不可预知的速度向前推进。为了保证异步的同时能够保证结果的可再现，配置了相应的进程同步机制。</li>\n</ol>\n<h3 store-v-md-heading=\"_2-2-进程的数据结构\" store-v-md-line=\"45\">2.2 进程的数据结构</h3>\n<p store-v-md-line=\"46\">在计算机中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，可称之为资源信息表和进程信息表。相同类型的表通常会通过指针连接成队列，OS管理的这些控制表一般可分为以下4类：内存表、设备表、文件表和用于进程管理的进程表。通常进程表又被称为进程控制块(Process Control Block,PCB)，也称为任务控制块(Task Control Block)。</p>\n<p store-v-md-line=\"48\"><img src=\"https://assets.windcoder.com/java_process_os_cotroltabls01.png\" alt=\"OS控制表的一般结构\"></p>\n<h4 store-v-md-heading=\"_2-2-1-pcb-中包含的信息\" store-v-md-line=\"50\">2.2.1 PCB 中包含的信息</h4>\n<p store-v-md-line=\"51\">在 PCB 中主要包含如下4中信息：</p>\n<ol store-v-md-line=\"52\">\n<li><strong>进程标识符</strong> ：进程标识符用于唯一地标志一个进程。一个进程通常有<strong>外部标识符</strong>和<strong>内部标识符</strong>这两种标识符。\n<ul store-v-md-line=\"53\">\n<li><strong>外部标识符</strong>：为方便用户（进程）对进程的访问所设置。通常由字母与数组组成。为描述进程的家族关系，需要设置父进程和子进程标识符。为了指示拥有此进程的用户，还可以设置用户标识符。</li>\n<li><strong>内部标识符</strong>：为方便系统对进程的使用。</li>\n</ul>\n</li>\n<li><strong>处理机状态</strong> ：处理机状态信息，也称为处理机上下文，主要是由处理机的各种寄存器中的内容组成，当处于执行状态时，正在处理的信息需要放在寄存器中，当被切换时，处理机状态信息必须保存在相应的 PCB 中。\n<ul store-v-md-line=\"56\">\n<li><strong>通用寄存器</strong> ：又称为用户可视寄存器，可被用户程序访问，用于暂存信息。</li>\n<li><strong>指令计数器</strong> ：存放了要访问的下一条指令的地址。</li>\n<li><strong>程序状态字寄存器</strong> ：含有状态信息，如条件码、执行方式、中断屏蔽标识等。</li>\n<li><strong>用户栈指针寄存器</strong> ：每个用户进程都有一个或若干个与之相关的系统栈，用于存放进程和系统的调用参数以及调用地址。</li>\n</ul>\n</li>\n<li><strong>进程调度信息</strong> ：OS在进行进程调度时，需要了解进程的状态以及有关进程的调度信息：\n<ul store-v-md-line=\"61\">\n<li><strong>进程状态</strong>：指明进程当前的状态，用于进程调度和对换时的数据。</li>\n<li><strong>进程优先级</strong> ：优先级高的进程应优先获得处理机。</li>\n<li><strong>进程调度所需的其它信息</strong> ：如进程已经等待CPU的时间总和，进程已经执行时间的总和等，与所选调度算法有关。</li>\n<li><strong>事件</strong>：即阻塞原因，进程由执行转到阻塞状态所等待发生的事件。</li>\n</ul>\n</li>\n<li><strong>进程控制信息</strong> ：用于进程控制所必需的信息。\n<ul store-v-md-line=\"66\">\n<li><strong>程序和数据的地址</strong> ：进程中程序和数据的内/外存地址，方便再次调度到该进程执行时快速从 PCB 中找到其程序与数据。</li>\n<li><strong>进程同步和通信机制</strong> ：辍学进程同步和进程通信时所必需的机制，如消息队列指针等</li>\n<li><strong>资源清单</strong> ：列出了进程在运行期间除CPU外的所需的全部资源</li>\n<li><strong>链接指针</strong> ：指出本进程所在队列的下一个进程的 PCB 的起始地址。</li>\n</ul>\n</li>\n</ol>\n<p store-v-md-line=\"71\"><img src=\"https://assets.windcoder.com/java_process_pcb01.png\" alt=\"进程间的CPU切换\"></p>\n<h4 store-v-md-heading=\"_2-2-1-pcb-的组织方式\" store-v-md-line=\"73\">2.2.1 PCB 的组织方式</h4>\n<p store-v-md-line=\"74\">目前针对 PCB 常用的组织方式有如下3中方案：</p>\n<ol store-v-md-line=\"75\">\n<li><strong>线性方式</strong> ：将系统中所有的PCB都组织在一张线性表中，将该表的起始地址放在内存的一个专用区域中。该方式实现简单且开销小，但每次查找时需要全表扫描，因此适合PCB不多的系统。</li>\n<li><strong>链接方式</strong> ：通过 PCB 中的连接字，将具有相同状态的进程的PCB分别链接成一个队列。如此可形成就绪队列、若干阻塞队列和空闲队列等。\n<ul store-v-md-line=\"77\">\n<li><strong>就绪队列</strong>：按优先级从高到低排列。</li>\n<li><strong>阻塞队列</strong>：可根据不同的阻塞原因，将相同原因的PCB链接成一个队列。</li>\n</ul>\n</li>\n<li><strong>索引方式</strong> ：系统根据所有进程状态的不同，建立几张索引表，如就绪索引表、阻塞索引表等，并把各个索引表在内存中的起始地址记录在内存的专用单元中。在每个索引表的目录中记录具有相应状态的某个PCB在PCB表中的地址。</li>\n</ol>\n<p store-v-md-line=\"81\"><img src=\"https://assets.windcoder.com/java_process_pcb02.png\" alt=\"PCB组织方式\"></p>\n<h4 store-v-md-heading=\"_2-2-1-pcb-的作用\" store-v-md-line=\"83\">2.2.1 PCB 的作用</h4>\n<ol store-v-md-line=\"85\">\n<li><strong>作为独立运行基本单位的标志</strong> ：系统通过PCB来感知进程的存在的，PCB已经成为进程存在于系统中的唯一标志。</li>\n<li><strong>实现间断性运行方式</strong> ：在PCB中保存自己运行时的CPU现场信息，当其再次被调度时，便可迅速恢复自己的信息，从而继续运行。\n<ul store-v-md-line=\"87\">\n<li>在多道程序的环境下，作为传统意义上的静态程序，因为其不具有保护或者保存自己运行现场的手段，故无法保证运行结果的可再现性，从而失去了运行的意义。</li>\n</ul>\n</li>\n<li><strong>提供进程管理所需要的信息</strong> ：在进程的整个生命周期中，OS都是根据PCB来实施对进程的控制和管理的。比如：\n<ul store-v-md-line=\"89\">\n<li>调度程序调度到某个进程时，只能根据该进程的PCB中记录的程序和数据在内/外存中的起始地址(又称“始址”或者“基址”)找到相应程序与数据。</li>\n<li>进程运行过程中，访问系统中的文件或者I/O时，也需要借助PCB中的信息。</li>\n<li>可以根据PCB的资源清单了解该进程所需的全部资源信息等。</li>\n</ul>\n</li>\n<li><strong>提供进程调用所需要的信息</strong> ：只有处于就绪状态的进程才可被调度，PCB中提供了进程所处状态等信息。</li>\n<li><strong>实现与其他进程的同步与通信</strong> ：进程同步机制是用于实现各个进程的协调运行的。\n<ul store-v-md-line=\"94\">\n<li>在采用信号量机制时，要求在每个进程中都设置相应的用于同步的信号量。</li>\n<li>PCB中还具有用于实现进程通信的区域或者通信队列等。</li>\n</ul>\n</li>\n</ol>\n<h2 store-v-md-heading=\"_3-参考资料\" store-v-md-line=\"97\">3. 参考资料</h2>\n<ol store-v-md-line=\"99\">\n<li>《计算机操作系统(慕课版)》汤子瀛等</li>\n<li>《操作系统概念(原书第9版)》</li>\n</ol>\n"
	a := RemoveHtmlAndSubstring(data)
	log.Println("TestRemoveHtmlAndSubstring 结果：", a)
}

func TestRunMD5(t *testing.T) {
	//a := PinyinConvert("【译】Oracle调优技巧22：Hash Outer Join")
	a := MD5ByStr("12345")
	log.Println("结果：", a)
}
